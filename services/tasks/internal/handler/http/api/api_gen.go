// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.0.0 DO NOT EDIT.
package api

import (
	"fmt"
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// AccountAuth defines model for AccountAuth.
type AccountAuth struct {
	Login    string `json:"login"`
	Password string `json:"password"`
}

// AccountCreate defines model for AccountCreate.
type AccountCreate struct {
	Login    string `json:"login"`
	Password string `json:"password"`
}

// AccountGet defines model for AccountGet.
type AccountGet struct {
	CreatedAt time.Time          `json:"createdAt"`
	Id        openapi_types.UUID `json:"id"`
	Login     string             `json:"login"`
	UpdatedAt time.Time          `json:"updatedAt"`
}

// AccountUpdate defines model for AccountUpdate.
type AccountUpdate struct {
	Id       openapi_types.UUID `json:"id"`
	Login    string             `json:"login"`
	Password string             `json:"password"`
}

// JwtToken defines model for JwtToken.
type JwtToken struct {
	Token *string `json:"token,omitempty"`
}

// ModelUUID defines model for ModelUUID.
type ModelUUID struct {
	Id openapi_types.UUID `json:"id"`
}

// TaskCreate defines model for TaskCreate.
type TaskCreate struct {
	CreatedBy openapi_types.UUID `json:"createdBy"`
	EndedAt   time.Time          `json:"endedAt"`
	Name      string             `json:"name"`
	StartedAt time.Time          `json:"startedAt"`
	Text      string             `json:"text"`
}

// TaskGet defines model for TaskGet.
type TaskGet struct {
	CreatedAt time.Time          `json:"createdAt"`
	CreatedBy openapi_types.UUID `json:"createdBy"`
	EndedAt   time.Time          `json:"endedAt"`
	Id        openapi_types.UUID `json:"id"`
	Name      string             `json:"name"`
	StartedAt time.Time          `json:"startedAt"`
	Status    string             `json:"status"`
	Text      string             `json:"text"`
	UpdateAt  time.Time          `json:"updateAt"`
}

// TaskUpdate defines model for TaskUpdate.
type TaskUpdate struct {
	CreatedBy openapi_types.UUID `json:"createdBy"`
	EndedAt   time.Time          `json:"endedAt"`
	Id        openapi_types.UUID `json:"id"`
	Name      string             `json:"name"`
	StartedAt time.Time          `json:"startedAt"`
	Status    string             `json:"status"`
	Text      string             `json:"text"`
}

// GetAccountsParams defines parameters for GetAccounts.
type GetAccountsParams struct {
	Id *openapi_types.UUID `form:"id,omitempty" json:"id,omitempty"`
}

// GetTasksParams defines parameters for GetTasks.
type GetTasksParams struct {
	Id          *openapi_types.UUID `form:"id,omitempty" json:"id,omitempty"`
	CreatedBy   *openapi_types.UUID `form:"createdBy,omitempty" json:"createdBy,omitempty"`
	Status      *string             `form:"status,omitempty" json:"status,omitempty"`
	StartedAtLB *time.Time          `form:"startedAtLB,omitempty" json:"startedAtLB,omitempty"`
	StartedAtRB *time.Time          `form:"startedAtRB,omitempty" json:"startedAtRB,omitempty"`
	EndedAtLB   *time.Time          `form:"endedAtLB,omitempty" json:"endedAtLB,omitempty"`
	EndedAtRB   *time.Time          `form:"endedAtRB,omitempty" json:"endedAtRB,omitempty"`
}

// PatchTasksParams defines parameters for PatchTasks.
type PatchTasksParams struct {
	Id     openapi_types.UUID `form:"id" json:"id"`
	Status string             `form:"status" json:"status"`
}

// PostAccountsJSONRequestBody defines body for PostAccounts for application/json ContentType.
type PostAccountsJSONRequestBody = AccountCreate

// PutAccountsJSONRequestBody defines body for PutAccounts for application/json ContentType.
type PutAccountsJSONRequestBody = AccountUpdate

// PostAuthJSONRequestBody defines body for PostAuth for application/json ContentType.
type PostAuthJSONRequestBody = AccountAuth

// PostTasksJSONRequestBody defines body for PostTasks for application/json ContentType.
type PostTasksJSONRequestBody = TaskCreate

// PutTasksJSONRequestBody defines body for PutTasks for application/json ContentType.
type PutTasksJSONRequestBody = TaskUpdate

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List Accounts
	// (GET /accounts)
	GetAccounts(c *gin.Context, params GetAccountsParams)
	// Create an Accounts
	// (POST /accounts)
	PostAccounts(c *gin.Context)
	// Update account
	// (PUT /accounts)
	PutAccounts(c *gin.Context)
	// Login
	// (POST /auth)
	PostAuth(c *gin.Context)
	// List tasks
	// (GET /tasks)
	GetTasks(c *gin.Context, params GetTasksParams)
	// Change task status
	// (PATCH /tasks)
	PatchTasks(c *gin.Context, params PatchTasksParams)
	// Create a task
	// (POST /tasks)
	PostTasks(c *gin.Context)
	// Update a task
	// (PUT /tasks)
	PutTasks(c *gin.Context)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// GetAccounts operation middleware
func (siw *ServerInterfaceWrapper) GetAccounts(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAccountsParams

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", c.Request.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetAccounts(c, params)
}

// PostAccounts operation middleware
func (siw *ServerInterfaceWrapper) PostAccounts(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostAccounts(c)
}

// PutAccounts operation middleware
func (siw *ServerInterfaceWrapper) PutAccounts(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PutAccounts(c)
}

// PostAuth operation middleware
func (siw *ServerInterfaceWrapper) PostAuth(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostAuth(c)
}

// GetTasks operation middleware
func (siw *ServerInterfaceWrapper) GetTasks(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTasksParams

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", c.Request.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "createdBy" -------------

	err = runtime.BindQueryParameter("form", true, false, "createdBy", c.Request.URL.Query(), &params.CreatedBy)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter createdBy: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", c.Request.URL.Query(), &params.Status)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter status: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "startedAtLB" -------------

	err = runtime.BindQueryParameter("form", true, false, "startedAtLB", c.Request.URL.Query(), &params.StartedAtLB)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter startedAtLB: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "startedAtRB" -------------

	err = runtime.BindQueryParameter("form", true, false, "startedAtRB", c.Request.URL.Query(), &params.StartedAtRB)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter startedAtRB: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "endedAtLB" -------------

	err = runtime.BindQueryParameter("form", true, false, "endedAtLB", c.Request.URL.Query(), &params.EndedAtLB)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter endedAtLB: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "endedAtRB" -------------

	err = runtime.BindQueryParameter("form", true, false, "endedAtRB", c.Request.URL.Query(), &params.EndedAtRB)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter endedAtRB: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetTasks(c, params)
}

// PatchTasks operation middleware
func (siw *ServerInterfaceWrapper) PatchTasks(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchTasksParams

	// ------------- Required query parameter "id" -------------

	if paramValue := c.Query("id"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument id is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "id", c.Request.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "status" -------------

	if paramValue := c.Query("status"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument status is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "status", c.Request.URL.Query(), &params.Status)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter status: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PatchTasks(c, params)
}

// PostTasks operation middleware
func (siw *ServerInterfaceWrapper) PostTasks(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostTasks(c)
}

// PutTasks operation middleware
func (siw *ServerInterfaceWrapper) PutTasks(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PutTasks(c)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/accounts", wrapper.GetAccounts)
	router.POST(options.BaseURL+"/accounts", wrapper.PostAccounts)
	router.PUT(options.BaseURL+"/accounts", wrapper.PutAccounts)
	router.POST(options.BaseURL+"/auth", wrapper.PostAuth)
	router.GET(options.BaseURL+"/tasks", wrapper.GetTasks)
	router.PATCH(options.BaseURL+"/tasks", wrapper.PatchTasks)
	router.POST(options.BaseURL+"/tasks", wrapper.PostTasks)
	router.PUT(options.BaseURL+"/tasks", wrapper.PutTasks)
}
